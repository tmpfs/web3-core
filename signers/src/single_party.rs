//! Signer that manages a single-party private key using `k256`.
use async_trait::async_trait;
use k256::{
    ecdsa::{
        recoverable,
        signature::{Signer, Verifier},
        SigningKey, VerifyingKey,
    },
    elliptic_curve::sec1::ToEncodedPoint,
    FieldBytes, PublicKey,
};
use rand_core::{CryptoRng, RngCore};
use std::fmt;
use thiserror::Error;

use crate::traits::Sign;
use ethereum_types::{Address, U256};
use web3_hash_utils::keccak256;
use web3_signature::Signature;

/// Errors generated by the single party signing implementation.
#[derive(Debug, Error)]
pub enum SinglePartyError {
    /// Errors thrown by the ECDSA implementation.
    #[error(transparent)]
    Ecdsa(#[from] k256::ecdsa::Error),
    /// Errors thrown by the elliptic curve implementation.
    #[error(transparent)]
    EllipticCurve(#[from] k256::elliptic_curve::Error),
    /// Errors thrown attempting to convert from a slice.
    #[error(transparent)]
    TryFromSlice(#[from] std::array::TryFromSliceError),
}

/// Single party ECDSA signer implementation.
#[derive(Eq, PartialEq)]
pub struct SingleParty {
    secret_key: SigningKey,
}

impl SingleParty {
    /// Generate a random single party signer.
    pub fn random(rng: impl CryptoRng + RngCore) -> Self {
        Self {
            secret_key: SigningKey::random(rng),
        }
    }
}

#[async_trait]
impl Sign for SingleParty {
    type Error = SinglePartyError;

    async fn sign<S: Send + Sync + AsRef<[u8]>>(
        &self,
        message: S,
    ) -> Result<Signature, Self::Error> {
        let sig: recoverable::Signature =
            self.secret_key.sign(message.as_ref());

        let r_bytes: FieldBytes = sig.r().into();
        let s_bytes: FieldBytes = sig.s().into();
        let v: u8 = sig.recovery_id().into();
        let signature = Signature {
            r: U256::from_big_endian(r_bytes.as_slice()),
            s: U256::from_big_endian(s_bytes.as_slice()),
            v: v as u64,
        };

        Ok(signature)
    }

    fn verify<S: Send + Sync + AsRef<[u8]>>(
        &self,
        message: S,
        signature: &Signature,
    ) -> Result<(), Self::Error> {
        let bytes = signature.to_bytes();
        let sig = k256::ecdsa::Signature::try_from(bytes.as_slice())?;
        let verify_key = VerifyingKey::from(&self.secret_key);
        Ok(verify_key.verify(message.as_ref(), &sig)?)
    }

    fn address(&self) -> Address {
        let public_key = PublicKey::from(&self.secret_key.verifying_key());
        let public_key =
            public_key.to_encoded_point(/* compress = */ false);
        let public_key = public_key.as_bytes();
        debug_assert_eq!(public_key[0], 0x04);
        let hash = keccak256(&public_key[1..]);
        Address::from_slice(&hash[12..])
    }

    fn to_bytes(&self) -> Vec<u8> {
        self.secret_key.to_bytes().as_slice().to_vec()
    }

    fn from_bytes(bytes: &[u8]) -> Result<Self, Self::Error> {
        let secret_key = SigningKey::from_bytes(bytes)?;
        Ok(SingleParty { secret_key })
    }
}

impl fmt::Display for SingleParty {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "0x{}", hex::encode(self.address()))
    }
}

impl fmt::Debug for SingleParty {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SingleParty")
            .field("address", &self.address())
            .finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::Result;

    #[tokio::test]
    async fn test_sign() -> Result<()> {
        let mut rng = rand::thread_rng();
        let signer = SingleParty::random(&mut rng);
        let message = b"a message to sign";
        let sig = signer.sign(message).await?;
        let _ = signer.verify(message, &sig);
        Ok(())
    }

    #[test]
    fn test_to_from_bytes() -> Result<()> {
        let mut rng = rand::thread_rng();
        let signer = SingleParty::random(&mut rng);
        let bytes = signer.to_bytes();
        let imported = SingleParty::from_bytes(&bytes)?;
        assert_eq!(signer, imported);
        Ok(())
    }
}
